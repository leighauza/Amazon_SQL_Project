-- ----------------------------- --
-- 20 Business Problem Solutions --
-- ----------------------------- --


-- #1 - Top Selling Products
-- Queries the top 10 products by total sales value.

SELECT
  order_items.product_id,
  products.product_name,
  SUM(quantity) AS total_quantity,
  ROUND(CAST(SUM(quantity*price_per_unit) AS NUMERIC), 2) AS total_sales

FROM order_items
  LEFT JOIN products
  ON products.product_id = order_items.product_id
GROUP BY order_items.product_id, products.product_name
ORDER BY total_sales DESC
LIMIT 10;

-- #2 - Revenue by Category
-- Calculates total revenue generated by each product category.

SELECT
  category.category_id,
  category.category_name,
  SUM(total_sale) AS total_sales,
  ROUND((SUM(total_sale)/(SELECT SUM(total_sale) FROM order_items))*100, 2) AS percentage
FROM order_items
LEFT JOIN  products
  ON products.product_id = order_items.product_id
LEFT JOIN category
  ON category.category_id = products.category_id
GROUP BY category.category_id, category.category_name
ORDER BY total_sales DESC;

-- #3 - Average Order Value (AOV)
-- Computes the average order value for each customer.

SELECT
  customers.customer_id,
  CONCAT(customers.first_name, ' ', customers.last_name) AS customer_name,
  ROUND(SUM(order_items.total_sale)/COUNT(orders.order_id), 2) AS average_order_value,
  COUNT(orders.order_id) AS total_orders
FROM order_items
JOIN orders ON orders.order_id = order_items.order_id
JOIN customers ON customers.customer_id = orders.customer_id

GROUP BY
  customers.customer_id
HAVING
  COUNT(orders.order_id) > 5
ORDER BY
  average_order_value DESC
LIMIT 10;

-- #4 - Monthly Sales Trend
-- Queries monthly total sales over the past year.

SELECT
  month,
  year,
  total_sales,
  LAG(total_sales, 1) OVER(ORDER BY year, month) AS last_month_sale

FROM (
  SELECT
    EXTRACT(MONTH FROM order_date) as month,
    EXTRACT(YEAR FROM order_date) as year,
    ROUND(SUM(order_items.total_sale::NUMERIC), 2) as total_sales
  FROM orders
    JOIN order_items
    ON orders.order_id = order_items.order_id
  WHERE order_date BETWEEN DATE '2023-08-01' AND DATE '2024-07-30'
  GROUP BY year, month
  ORDER BY year, month
) AS table_1;

-- #5 - Customers with No Purchases
-- Finds customers who have registered but never placed an order.

SELECT *
FROM customers as c
LEFT JOIN orders as o
ON o.customer_id = c.customer_id
WHERE o.customer_id IS NULL;

-- #6 - Least-Selling Categories by State
-- Identifies the least-selling product category for each state.

WITH ranking_table AS (

SELECT
  c.state as state,
  ca.category_name,
  SUM(oi.total_sale) as total_sale,
  RANK () OVER(PARTITION BY c.state ORDER BY SUM(oi.total_sale) ASC) as rank

FROM orders as o
JOIN customers as c
  ON o.customer_id = c.customer_id
JOIN order_items as oi
  ON o.order_id = oi.order_id
JOIN products as p
  ON p.product_id = oi.product_id
JOIN category as ca
  ON ca.category_id = p.category_id

GROUP BY 1, 2

)

SELECT *
FROM ranking_table
WHERE rank = 1;

-- #7 - Customer Lifetime Value (CLTV)
-- Calculates the total value of orders placed by each customer over their lifetime.

SELECT
  customers.customer_id,
  CONCAT(customers.first_name, ' ', customers.last_name) AS customer_name,
  SUM(total_sale) AS CLTV,
  DENSE_RANK() OVER(ORDER BY SUM(total_sale) DESC) AS cltv_rank
FROM order_items
JOIN orders ON orders.order_id = order_items.order_id
JOIN customers ON customers.customer_id = orders.customer_id

GROUP BY
  customers.customer_id
HAVING
  COUNT(orders.order_id) > 5
;

-- #8 - Inventory Stock Alerts
-- Query products with stock levels below a certain threshold (e.g., less than 10 units).

SELECT
  i.inventory_id,
  p.product_name,
  i.stock AS current_stock,
  i.last_stock_date,
  i.warehouse_id
FROM inventory as i
  JOIN products as p
  ON p.product_id = i.product_id
WHERE stock < 10;

-- #9 - Shipping Delays
-- Identifies orders where the shipping date is later than 3 days after the order date.

SELECT
  c.*,
  o.*,
  s.shipping_providers,
  (s.shipping_date - o.order_date) AS days_took_to_ship
FROM orders as o
JOIN customers as c
  ON c.customer_id = o.customer_id
JOIN shipping as s
  ON s.order_id = o.order_id

WHERE
  (s.shipping_date - o.order_date) > 3;

-- #10 - Payment Success Rate 
-- Calculates the percentage of successful payments across all orders.

SELECT
  payment_status,
  COUNT(*) as count,
  ROUND(COUNT(*)/(SELECT COUNT(*) FROM payments)::numeric * 100, 2) as status_percentage
FROM payments
GROUP BY payment_status;

-- #11 - Top Performing Sellers
-- Finds the top 5 sellers based on total sales value.

WITH top_sellers AS ( -- CTE: top 5 sellers based on revenue
  SELECT
    s.seller_id,
    s.seller_name,
    SUM(oi.total_sale) as total_sale
  FROM orders as o
  LEFT JOIN order_items as oi
    ON o.order_id = oi.order_id
  LEFT JOIN sellers as s
    ON s.seller_id = o.seller_id
  GROUP BY s.seller_id, s.seller_name
  ORDER BY total_sale DESC
  LIMIT 5
),

seller_reports AS ( -- CTE: to see different order status
  SELECT
    o.seller_id,
    ts.seller_name,
    o.order_status,
    COUNT(*) as order_count
  FROM orders as o
  JOIN top_sellers as ts
    ON o.seller_id = ts.seller_id
  WHERE
    o.order_status NOT IN ('Inprogress', 'Returned')
  GROUP BY o.seller_id, ts.seller_name, o.order_status
)

SELECT
  seller_id,
  seller_name,
  SUM(CASE WHEN order_status = 'Completed' THEN order_count ELSE 0 END) as completed_orders,
  SUM(CASE WHEN order_status = 'Cancelled' THEN order_count ELSE 0 END) as cancelled_orders,
  SUM(order_count) as total_orders,
  ROUND(SUM(CASE WHEN order_status = 'Completed' THEN order_count ELSE 0 END)::numeric/SUM(order_count)::numeric * 100, 2) as successful_order_percentage
FROM seller_reports
GROUP BY seller_id, seller_name;


-- #12 - Product Profit Margin
-- Calculates the profit margin for each product (difference between price and cost of goods sold).

SELECT
  product_id,
  product_name,
  profit_margin,
  DENSE_RANK() OVER(ORDER BY profit_margin DESC) as profit_rank

FROM (
  SELECT
    p.product_id as product_id,
    p.product_name as product_name,
    (SUM((oi.total_sale - oi.quantity * p.cogs))/
      SUM(oi.total_sale))*100::numeric as profit_margin

  FROM order_items as oi
  JOIN products as p
    ON oi.product_id = p.product_id
  GROUP BY p.product_id, p.product_name
  ORDER BY profit_margin DESC
) as table_1;


-- #13 - Most Returned Products
-- Queries the top 10 products by the number of returns.

SELECT 
  p.product_id,
  p.product_name,
  ROUND((COUNT (*) FILTER (WHERE o.order_status = 'Returned')::numeric / COUNT (*)::numeric)*100, 2) as return_rate
FROM orders as o
JOIN order_items as oi
  ON o.order_id = oi.order_id
JOIN products as p
  ON p.product_id = oi.product_id

GROUP BY 1,2
ORDER BY return_rate DESC
LIMIT 10;

-- #14 - Orders Pending Shipment
-- Finds orders that have been paid but are still pending shipment.

SELECT
  c.customer_id,
  c.first_name,
  c.last_name,
  c.state,
  o.order_date,
  p.payment_date

FROM orders as o 
JOIN payments as p
  ON o.order_id = p.order_id
JOIN customers as c
  ON c.customer_id = o.customer_id

WHERE p.payment_status = 'Payment Successed'
  AND o.order_status = 'Inprogress';

-- #15 - Inactive Sellers
-- Identifies sellers who havenâ€™t made any sales in the last 6 months.

SELECT
  s.seller_id,
  s.seller_name,
  MAX(o.order_date) AS last_sale_date,
  COALESCE(SUM(oi.total_sale), 0) AS total_sale

FROM sellers as s
LEFT JOIN orders as o
  ON s.seller_id = o.seller_id
JOIN order_items as oi
  ON o.order_id = oi.order_id

WHERE s.seller_id NOT IN (
  SELECT seller_id
  FROM orders
  WHERE order_date >= CURRENT_DATE - INTERVAL '6 months'
)

GROUP BY s.seller_id, s.seller_name
ORDER BY last_sale_date DESC;

-- #16 - Identify customers into returning or new
-- Categorizes customers as either returning or new according to how many returns they've made.

WITH initial_table AS(
  SELECT
    CONCAT(c.first_name, ' ', c.last_name) as full_name,
    COUNT(order_id) as total_orders,
    COUNT(CASE 
      WHEN order_status = 'Returned' THEN 1
      ELSE NULL
    END) AS total_returned

  FROM customers as c
  LEFT JOIN orders as o
    ON c.customer_id = o.customer_id

  GROUP BY full_name
)


SELECT *,
  CASE
    WHEN total_returned > 5 THEN 'returning'
    ELSE 'new'
  END AS customer_type
FROM initial_table;

-- #17 - Top 5 Customers by Orders in Each State
-- Identifies the top 5 customers with the highest number of orders for each state.

WITH customers_ranked AS (
  SELECT
    CONCAT(c.first_name, ' ', c.last_name) as customer_name,
    c.state,
    COUNT(o.order_id) as total_orders,
    ROUND(SUM(oi.total_sale), 2) as total_sales,
    RANK() OVER(PARTITION BY c.state ORDER BY COUNT(o.order_id) DESC, SUM(oi.total_sale) DESC) as rank

  FROM customers as c
  JOIN orders as o
    ON o.customer_id = c.customer_id
  JOIN order_items as oi
    ON oi.order_id = o.order_id

  GROUP BY c.state, c.customer_id
  ORDER BY c.state, COUNT(o.order_id) DESC
)

SELECT *
FROM customers_ranked
WHERE rank <= 5;

-- #18 - Revenue by Shipping Provider
-- Calculates the total revenue handled by each shipping provider.

SELECT
  s.shipping_providers as shipping_providers,
  COUNT(o.order_id) as total_orders,
  SUM(oi.total_sale) as total_sales,
  AVG(s.shipping_date - o.order_date) as ave_delivery_time

FROM shipping as s
JOIN orders as o
  ON s.order_id = o.order_id
JOIN order_items as oi
  ON oi.order_id = o.order_id

GROUP BY s.shipping_providers
ORDER BY total_orders DESC;

-- #19 Top 10 Products with Highest Decreasing Revenue Ratio
-- Computes top products with highest decreasing revenue ratio compared to last year(2022) and current_year(2023)

SELECT
    p.product_id,
    p.product_name,
    ca.category_name,
    SUM(CASE
        WHEN EXTRACT(YEAR FROM o.order_date) = 2022
        THEN oi.total_sale
        ELSE 0 
        END) AS total_sale_2022,
    SUM(CASE
        WHEN EXTRACT(YEAR FROM o.order_date) = 2023
        THEN oi.total_sale
        ELSE 0 
        END) AS total_sale_2023,
    ROUND((SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 2023 THEN oi.total_sale ELSE 0 END)
        - SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 2022 THEN oi.total_sale ELSE 0 END))
        / NULLIF(SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 2022 THEN oi.total_sale ELSE 0 END), 0)
        * 100, 2) AS ratio
    

FROM products as p
JOIN  category as ca
  ON p.category_id = ca.category_id
JOIN order_items as oi
  ON p.product_id = oi.product_id
JOIN orders as o
  ON oi.order_id = o.order_id

GROUP BY p.product_id, p.product_name, ca.category_name;

-- #20 - Store Procedure
-- This function handles the process of adding a sales transaction. It checks product availability, inserts order details, and updates inventory, and notifies the user of transaction status.

CREATE OR REPLACE FUNCTION add_sales(
    p_order_id INT,
    p_customer_id INT,
    p_seller_id INT,
    p_order_item_id INT,
    p_product_id INT,
    p_quantity INT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$

DECLARE
    v_count INT;
    v_price FLOAT;
    v_product VARCHAR(50);

BEGIN
    -- Fetch product name and price
    SELECT price, product_name 
    INTO v_price, v_product 
    FROM products 
    WHERE product_id = p_product_id; 

    -- Check stock and product availability
    SELECT COUNT(*) 
    INTO v_count 
    FROM inventory
    WHERE product_id = p_product_id
    AND stock >= p_quantity;
    
    IF v_count > 0 THEN
        -- Insert into orders
        INSERT INTO orders(order_id, order_date, customer_id, seller_id)
        VALUES (p_order_id, CURRENT_DATE, p_customer_id, p_seller_id);

        -- Insert into order items
        INSERT INTO order_items(order_item_id, order_id, product_id, quantity, price_per_unit, total_sale)
        VALUES (p_order_item_id, p_order_id, p_product_id, p_quantity, v_price, v_price * p_quantity);

        -- Update inventory
        UPDATE inventory
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        RAISE NOTICE 'Thank you for your purchase. Your order for % is confirmed.', v_product;
    
    ELSE
        RAISE NOTICE 'Thank you for your information. The product % is not available at the moment.', v_product;
    
    END IF;
    
END;
$$;

-- Function Tests
SELECT add_sales(25000, 2, 5, 25001, 1, 40);
SELECT add_sales(25002, 4, 7, 25003, 3, 15);
SELECT add_sales(25001, 3, 6, 25002, 2, 20);
