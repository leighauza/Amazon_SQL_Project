-----------------------
-- 50 BASIC SQL PROBLEMS --
-----------------------

-- 1. Basic Select: Retrieve the names of all products in the products table.

SELECT product_name
FROM products;

-- 2. Simple Join: Write a query to find the full name of customers (first_name + last_name) and the names of the products they ordered. Use a JOIN between customers, orders, and order_items.

SELECT
  CONCAT(c.first_name, ' ', c.last_name) AS full_name,
  p.product_name
FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id; 

-- 3. Conditional Select: List all products with a price greater than 100. Display the product name and price.

SELECT
  product_name,
  price
FROM products
WHERE price > 100;


-- 4. Inner Join: List all orders along with customer names and product names. Use INNER JOIN between orders, customers, and order_items.

SELECT
  o.order_id,
  CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
  p.product_name
FROM orders o
INNER JOIN customers c ON c.customer_id = o.customer_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id;

-- 5. Left Join: Retrieve all customers and their corresponding orders. Include customers who haven't placed any orders.

SELECT
  c.customer_id,
  CONCAT(c.first_name, ' ', c.last_name),
  o.order_id
FROM customers c
LEFT JOIN orders o ON o.customer_id = c.customer_id;
-- Result: 21,841 rows - meaning: there are customers who have not ordered.

-- 6. Right Join: Retrieve all orders and their corresponding customers. Include orders without customer information.

SELECT
  o.order_id,
  c.customer_id,
  CONCAT(c.first_name, ' ', c.last_name)
FROM customers c
RIGHT JOIN orders o ON o.customer_id = c.customer_id;
-- Result: 21,632 rows - observations: same with INNER JOIN, meaning: there are no records without customer information

-- 7. Join with Filtering: List all products sold by sellers originating from 'USA.' Include product names and seller names.

SELECT DISTINCT              -- Ensures only unique product-seller pairs come up.
  s.seller_name,
  p.product_name

FROM sellers s
INNER JOIN orders o ON o.seller_id = s.seller_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id

WHERE s.origin = 'USA';

-- side exploration "EXCEPT"

SELECT *
FROM sellers s
LEFT JOIN orders o ON o.seller_id = s.seller_id
LEFT JOIN order_items oi ON oi.order_id = o.order_id
LEFT JOIN products p ON p.product_id = oi.product_id

EXCEPT

SELECT *
FROM sellers s
INNER JOIN orders o ON o.seller_id = s.seller_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id;

-- 8. Multi-table Join: Write a query to find the total amount paid for each order. Include the orders, order_items, and payments tables.

SELECT
  o.order_id,
  SUM(oi.total_sale) AS total_amount_paid

FROM orders o
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN payments p ON p.order_id = o.order_id

GROUP BY o.order_id
ORDER BY o.order_date;

-- 9. Join with Subquery: List the customers who have ordered products in the 'electronics' category. Use a subquery to find the category ID.

SELECT DISTINCT                       -- There is no difference between SELECT DISTICT CONCAT() vs. SELECT DISTINCT(CONCAT())
  CONCAT(c.first_name, ' ', c.last_name) as customer_name

FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id

WHERE p.category_id = (               -- Reminder: can use IN instead of "=" for multiple options.
  SELECT category_id FROM category WHERE category_name = 'electronics');


-- 10. Cross Join: Write a query to list all combinations of category and sellers.

SELECT                    -- CROSS JOINs do not require a similar key.
  c.category_name,
  s.seller_name
FROM category c
CROSS JOIN sellers s;

-- 11. Count Function: Count the total number of unique customers in the customers table.

SELECT
  COUNT(DISTINCT c.customer_id) AS unique_customers
FROM customers c;


-- 12. Sum and Group By: Find the total revenue generated by each seller. Display the seller name and total revenue.

SELECT
  s.seller_name,
  SUM(oi.total_sale) AS total_revenue

FROM orders o
INNER JOIN sellers s ON s.seller_id = o.seller_id
INNER JOIN order_items oi ON oi.order_id = o.order_id

WHERE o.order_status = 'Completed'                   -- Ensures valid sales.
GROUP BY s.seller_name;

-- 13. Average Function: Calculate the average price of products in the products table.

SELECT
  ROUND(AVG(price)::NUMERIC, 2) AS avg_price
FROM products;

-- 14. Group By with Having: List all sellers who have sold more than 500 products. Display seller names and total products sold.

SELECT
  s.seller_id,
  s.seller_name,
  COUNT(oi.order_item_id) AS total_units_sold
FROM sellers s
INNER JOIN orders o ON o.seller_id = s.seller_id
INNER JOIN order_items oi ON oi.order_id = o.order_id

GROUP BY s.seller_id, s.seller_name
HAVING COUNT(oi.order_item_id) > 500          
ORDER BY total_units_sold DESC;

-- 15. Group By Multiple Columns: Find the total revenue generated by each seller for each category. Display seller names, category names, and total revenue.

SELECT
  ca.category_name,
  s.seller_name,
  SUM(oi.total_sale),
  RANK() OVER(PARTITION BY ca.category_name ORDER BY SUM(total_sale) DESC) AS revenue_rank

FROM orders o
INNER JOIN sellers s ON s.seller_id = o.seller_id
INNER JOIN order_items oi ON oi.order_id = o.order_id
INNER JOIN products p ON p.product_id = oi.product_id
INNER JOIN category ca ON ca.category_id = p.category_id

GROUP BY ca.category_name, s.seller_name
ORDER BY ca.category_name, revenue_rank;

-- 16. Count and Distinct: Find the total number of distinct products sold in each category.

SELECT
  ca.category_name AS category,
  COUNT(DISTINCT(product_id)) AS number_of_products

FROM category ca
INNER JOIN products p ON p.category_id = ca.category_id

GROUP BY ca.category_name
ORDER BY number_of_products DESC;

-- 17. Join with Aggregation: Write a query to find the total number of orders and the total revenue generated for each customer.

SELECT
  CONCAT(c.first_name, ' ', c.last_name) AS full_name,
  COUNT(DISTINCT o.order_id) AS total_orders,            -- Good practice to use DISTINCT to ensure unique + to write final name
  SUM(oi.total_sale) AS total_revenue

FROM customers c                                         -- So we can show even those customers that have not bought
LEFT JOIN orders o ON o.customer_id = c.customer_id
LEFT JOIN order_items oi ON oi.order_id = o.order_id

GROUP BY full_name
ORDER BY total_revenue DESC;

-- 18. Aggregate Functions and CASE: Find the number of orders for each order status ('Inprogress,' 'Delivered,' etc.). Use CASE to categorize the statuses. 
-- Re-categorized order status

SELECT
  CASE
    WHEN o.order_status IN ('Inprogress') THEN 'In Progress'
    WHEN o.order_status IN ('Completed') THEN 'Delivered'
    WHEN o.order_status IN ('Returned', 'Cancelled') THEN 'Cancelled'
  END AS categorized_status,
  COUNT(o.order_id) AS count

FROM orders o
INNER JOIN  order_items oi ON o.order_id = oi.order_id
WHERE order_status IS NOT NULL

GROUP BY categorized_status
ORDER BY count DESC;

-- 19. Nested Aggregation: Find the category with the highest total revenue.
-- Solution is simpler than nested aggregation approach.

SELECT
  ca.category_name,
  SUM(oi.total_sale) AS total_revenue

FROM category ca
INNER JOIN products p ON p.category_id = ca.category_id
INNER JOIN order_items oi ON oi.product_id = p.product_id

GROUP BY ca.category_name
ORDER BY total_revenue DESC
LIMIT 1;

-- 20. Conditional Aggregation: Count the number of successful and failed payments for each customer.

SELECT
  CONCAT(c.first_name, ' ', c.last_name) AS full_name,
  COUNT(CASE WHEN p.payment_status = 'Payment Successed' THEN o.order_id END) AS successful_payments,
  COUNT(CASE WHEN p.payment_status = 'Payment Failed' THEN o.order_id END) AS failed_payments

FROM orders o
INNER JOIN customers c ON c.customer_id = o.customer_id
INNER JOIN payments p ON p.order_id = o.order_id

GROUP BY full_name
ORDER BY successful_payments DESC;

-- 21. Simple Subquery: Find the product with the highest price. Use a subquery to get the maximum price.

SELECT
  product_name,
  price

FROM products
WHERE price = (SELECT MAX(price) FROM products);

-- 22. Correlated Subquery: Find all products whose price is above the average price in their category.

SELECT 
  p.product_name,
  p.price,
  ca.category_name
FROM products p
LEFT JOIN category ca ON ca.category_id = p.category_id
WHERE p.price > (
  SELECT AVG(price)
  FROM products
  WHERE category_id = p.category_id
);


-- 23. Subquery in WHERE Clause: Retrieve the names of customers who have ordered at least one product in the 'Pet Supplies' category.



-- 24. Subquery in SELECT Clause: For each product, display its name and the total number of times it has been ordered.
-- 25. Subquery with EXISTS: List all customers who have made at least one order.
-- 26. IN Clause with Subquery: Find the names of sellers who have sold 'Apple' products.
-- 27. NOT IN Clause: List all customers who have not placed any orders.
-- 28. Subquery with JOIN: Find the names of products that are out of stock. Use a subquery to get product IDs with stock = 0 in the inventory table.
-- 29. Subquery with HAVING: Retrieve sellers who have an average selling price of their products greater than 300.
-- 30. Multi-level Subqueries: Find the product that has generated the highest revenue. Use nested subqueries to calculate revenue.
-- 31. RANK() Function: For each category, rank the products based on their total sales amount.
-- 32. DENSE_RANK() Function: List the top 5 customers based on the total amount spent. Use DENSE_RANK().
-- 33. ROW_NUMBER() Function: Assign a row number to each product in the products table, ordered by price descending.
-- 34. NTILE() Function: Divide all customers into 4 quartiles based on the total amount they have spent.
-- 35. OVER Clause: For each order, calculate the running total of sales for the corresponding customer.
-- 36. PARTITION BY Clause: Find the total revenue generated by each seller in each year.
-- 37. LEAD() Function: For each product, find the next higher-priced product in the same category.
-- 38. LAG() Function: For each product, find the previous lower-priced product in the same category.
-- 39. Cumulative Sum: Calculate the cumulative sum of sales for each seller.
-- 40. Window Function with Aggregation: Find the average order amount for each customer and compare it with their individual orders.
-- 41. Date Filtering: List all orders placed in the current month. Include order ID, order date, and customer name.
-- 42. Extract and Group By: Find the number of orders placed in each year. Use the EXTRACT() function to group by year.
-- 43. DATEDIFF Function: Calculate the average delivery time for all delivered orders.
-- 44. DATE_TRUNC Function: Find the total sales amount for each month in the current year.
-- 45. Age Function: Find customers who have not placed any orders in the last 6 months.
-- 46. Date Conversion: Convert the order_date to a different format (e.g., 'YYYY-MM-DD') and display it with the order ID.
-- 47. Date Arithmetic: Calculate the total number of days between the order date and shipping date for each order.
-- 48. Current Date Usage: Find all orders that are overdue for payment. Assume payment is due within 30 days of the order date.
-- 49. Weekend Orders: Retrieve all orders that were placed on weekends.
-- 50. Next Day Delivery: List all orders that were delivered the next day after shipping.